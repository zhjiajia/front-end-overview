## 写在这里
一篇文章写下来总是有原因的，但就像作者作答自己文章的阅读理解总是得不到满分一样，所以不妨速览一下，如果有什么是您感兴趣的，至少它还算成功。
### 为啥要写这篇文章
几年来，其实有非常多的笔记被笔者写下，多到以Mb计算。不过计算机领域，至少是前端部分，新概念、新技术、新版本，更新速度非常快，随着版本更替有些笔记就因此失去了价值，另外大多数笔记更像是一次巩固复习，之后就尘封在某处难以重见天日。这是需要思考，并从中获取教训的良好机会——如何写一篇持久的文章。
孔子云:学而时习之，不亦说乎？温故而知新，可以为师矣。三人行则必有我师。
白话来说，学习、复习、理解、共进，是快乐而进步的事情。
### 期望您的帮助
在十一期间我写下了最开始的版本，由于精力有限，只完成了少数部分。每日更新。
这篇文章以开源的形式发布在Github上，期待您向它进行:评论、内容扩展、错误指正。
### 那些.txt文件
有些内容不是md的而是txt的，尝试在vscode里使用ctrl+k 之后ctrl+j、1、2、3看看它的效果，这样的层级阅读也是不错的。
## 计算机世界
计算机的世界是如此严谨，就像数学一样，1+1=2，没错这就是基础，所有的内容都有迹可循，从最简单的开始。
如果你理解了它，那么你就有着涉足计算机领域的良好基础——规则与逻辑。
### 开始沟通
#### 一开始
两台计算机之间沟通如此简单，只需要一条数据线连接彼此，或者是无线的手段，这都是一样的。
但当更多的计算机需要沟通，它们就会出现更多的可能，情况可能是下面这样的：
- A通过长期的沟通认识了很多伙伴，A经常与他们交流。
- 一天A需要告诉所有人一条信息，说他准备明天出去旅游，这几天先不联系了。他可以去逐个的告诉所有伙伴，或者是通知几个人，然后让他们帮忙转发给更多的A需要通知的人。
- A还想到了一种方式：大家所有需要互相通知的内容都先告诉那个住在中心的F，别人需要信息时，只需要去找F，F说：得加钱。
- 相比于A不舍得加钱，CD之间离得远，它们希望通过F来进行通信，但信息又不想被别人看到，它们就进行了信息加密，这样就保证了它们之间通信的安全。
- 一段时间后，A想出一个好主意，整一个大喇叭，这样就不用费钱费力了，大家有什么事都用大喇叭交流，这就是局域网的开始。
#### 局域网
##### 集线器
最开始它们做了一个大喇叭，所有人都能听到，这样A的喊话就能被B听到了，但其他人会觉得比较烦，而且只能同时只能有一个人使用一个大喇叭，一起喊就会乱套。
##### 交换机
它们扔掉了那个开了扬声器的大喇叭，转而建造了电话交换中心。所有人可以打给电话交换中心的小姐姐，而电话交换中心有着所有人的联系方式(MAC)，当A打给电话交换机，告诉交换机转接B，AB通信这样就不会影响到他人了。
* 网络分段
尽管大家在一个局域网下，但依然组成了一些小圈子。它们分成了几个子网，有着不同的ip地址范围和子网掩码。某个子网专攻对外交流，某个子网有着更强的保密手段。
* VLAN
身份可不止可以有一个，我虽然物理上是当前局域网的，但是依然可以加入一个虚拟局域网来换一个圈子，因为交换机支持我这样做。
##### 路由器
除了内部交流，大家认为需要向外交流，而外面也有着不同的交流方式，所以大家准备了几个网络接口和一个路由表(配置路由相关信息或叫配置`网关`)，这被称为路由器，就像城墙一样。外部人员要表明身份(`ip`),然后根据路由表去走某个网络接口。
对于小E一家，它们决定对外共用一个ip来代表它们所有人，这叫`NAT`(网络地址转换)。
城墙通常能保护内部网络免受不良网络攻击，这叫`防火墙`。
高级一点的城墙像一个龟壳一样将某一处的高额流量分担给别的地方，这叫`负载均衡`。
有成员在外出时可以换身行头隐藏自己(虚拟ip,加密通信)，这样大家不知道内部的谁和外部的谁进行了通信。这叫`VPN`。
##### 更多的角色
本来大家都是平平无奇的计算机的。。。
* 服务器
F需要应对更多的沟通了，他决定升级自身硬件，于是有了更好的沟通所需的能力。
* 工作站
E更喜欢做一些图像类的工作，它为此升级了相关的硬件，现在它喜欢别人叫自己图像处理工作站了。
* 打印机
不知道这人怎么混进来的。
##### wifi
一种无线局域网技术
#### 互联网
孩子们长大了，它们很多不需要局域网就可以认识更多人了。
通过`宽带`(高带宽的互联网连接，如光纤、移动数据网络)就可以直连互联网了。
除了宽带，拨号上网、卫星互联网、有线电视等也可以。
对于光纤，还需要`光猫`来将光信号转为电信号，猫还可以连接路由器进而为局域网服务。
### 沟通内容
0. 就像是科技的发展靠烧开水一样，计算机的发展靠沟通。就像你此刻读到内容一样。了解计算机如何沟通和理解沟通内容，就是这一步的话题。
1. 计算机发出信息可以是通过电(有线)或者无线电波(无线)，接收时再转为数字信号。(当然，您作为计算机的使用者不必担心，您并不需要产生电去发送。)
至少来说，在计算机和数字通信领域，这种数字信号是二进制的。`二进制`对于计算机的存储、交流简单高效，但人类难以阅读，所以在发送二进制信息的同时，要发送编码信息。
`编码`是将信息转换为另一种信息的过程，比如数字信号转模拟信号、ASCII编码用于文本数据、JPEG编码用于图像数据以及MP3编码用于音频数据。
比如当A向B发送信息，A计算机会将信息编码为二进制内容，由B接收，然后再进行对应的编码，呈现其能看懂的内容：文本、音频、图像等等。
不过这样来回发送看起来毫无章法，也不安全，所以通信时会带上协议，大家遵守某些协议，以便更好的通信。
2. 各类协议以QQ举例
QQ是计算机软件，其拥有着良好的图形界面供计算机用户使用，并且使用了足够的网络协议进行通信。启动QQ，它通过TCP/IP协议来与老马服务器通信，http传输文本、图像、音视频，websocket主动推送，STUN来音视频通话、IMAP使用电子邮件等等。
3. B/S与C/S架构
通俗来讲，B/S就是你的浏览器，而C/S是各类软件。
举例来说，QQ是一个客户端软件，而Browser就是指web浏览器，例如Chrome、Edge、Firefox、(你可以在仍和地方看到的)IE等等。
Browser的优点是跨平台、高安全、易更新，而需求高性能和复杂性则需Client或者是混合架构。
如果你想了解更多细节，可以使用任何的有效沟通方式，比如现在就去浏览器里，然后搜索："什么是B/S？"  ！
(什么，你想为什么没有提到网络体系结构？这里又不需要考试)
### 小结
总而言之，获取信息并加以利用，这就是几乎全部的你需要在计算机世界要做的内容。
## 前端
提到前端，我们想到的是浏览器页面上呈现的那些stuff。没错，但......广义来讲，前端指的是所有(用户能够)看见的东西，你大可以发挥想象。不过，千里之行始于足下，让我们脚踏实地，从头开始。
在浏览器你能浏览到很多网站，实际上，这就是另一台电脑(或者说服务器)向你的页面发送的信息。
### 通常我们在浏览器搜索内容
一天做饭，你想知道豆角怎样做好吃。你打开了浏览器，向搜索框输入了"豆角怎样做好吃？"，接下来是会发生的事情：
0. 你的输入框下方可能展示一些搜索相关建议，这是根据你的浏览器中的历史搜索记录以及搜索引擎的热门相关推荐。
1. 按下回车后，浏览器将你输入的内容发送给搜索引擎(比如百度、Google)，它会经理一系列的复杂算法最后获取一些关于你查询内容的最佳搜索结果，然后再发送给你的浏览器。
2. 最后，浏览器向你展现搜索结果页面，其中包含了搜索查询相关的网页列表。
3. 你点开一个或是多个页面，来浏览你想要得到的信息。
或许你听说过`SEO`,没错，想要你编写的页面出现在搜索结果页面的前方，使用SEO页面是个不错的主意。
### 这次在url框中输入
你或许注意到，每次页面的变化都会导致浏览器上方的一个框的变化，点击时你发现这里能够输入。
这里是`url`框，搜索结果页面中的那些网页列表下面你也可以看到它们对应的网址——网络地址。
更准确的讲，是叫url。所以下一次如果想进入某个网站，或许直接输入url是更快速的选择。
这次你向url框输入了 `www.baidu.com`,然后按下回车，你就直接进入了百度的页面，或是其它任何的网站。
#### url
常见的，一个url是 比如："www.123.com" 没错，但url也可以包括更多的内容："https://www.123.com:8080/index.html?lang=en#section1" ，拆开来看：
* 协议 https://
    用户没有输入协议，默认使用"http://" 作为协议，这是超文本传输协议(HTTP是一种无状态的(意为不会存储用户信息)，以请求/应答方式运行的协议，灵活的互动。)，https是加密的http协议，更加安全
    其它常见的有ws://实时通信协议，file://本地文件系统协议
* 域名 www.123.com
    ip是你在互联网中的大名，ip是一个小名，别人可以更好的记住你。
    域名需要由DNS解析为ip，这样才能与这个ip建立连接。
* 端口号 :1234
    你的ip代表了你的计算机，而端口就代表了你的某个应用或服务，这样数据才知道要送给哪个应用。例如，浏览器进行http请求时，会使用80这个默认的端口来向服务器发送请求。
* 路径 ab/cd/e.html
    更加具体的位置，这代表这ab文件夹下的cd下的e.html文件
    在单页应用中，你会在路由的位置看到#开头的路径，这是hash路由，等到单页应用的时候我们再细聊。
* 查询参数 ?a=1&b=2
    服务器可以通过查询参来来得到你更多的请求信息
* 片段标识符 #section1
    片段标识符可以跳转到页面的某个位置，只需这个位置有一个跳转标识```<a href="#section1">点我跳转</a>```。
#### 浏览器都做了哪些
0. 在这里输入时，虽然没有搜索引擎的相关推荐，但浏览器可能会提供补全建议。
1. 按下回车后，浏览器尝试分析你输入的url内容，拆解成不同的部分解析：
    * 协议告诉了浏览器如何与服务器通信以检索资源。
    * 域名会通过DNS解析为ip(你可以了解关于DNS相关的更多信息，但总之。)
    * 端口号如果未指定，则使用协议默认的端口号
    * 路径、查询参数、片段标识符可以指定更具体的位置
2. 与目标ip建立`TCP`连接，建立好后，浏览器发送http请求到服务器，服务器根据请求内容返回响应内容。
3. 浏览器接收到响应内容，然后进行处理：
首先解析响应头，然后根据响应的`状态码`的不同做对应处理,你可以搜索常见的状态码。
4. 解析响应体
响应头的Content-Type表明了响应体的内容，内容类型如果是Content-Type:html(HTML文档)，那么就构建文档对象模型(DOM)，并请求其内可能包含的<link>标签的css或是<script>标签中的js。如果不希望浏览器因为额外的css、js内容中断html的解析，那么可以使用async和defer关键字。
5. 根据dom树和css树构建渲染树，其包含了所有要再页面上显示的内容。
6. 根据渲染树计算页面布局，然后绘制页面以显示给用户。
7. 执行js代码。
8. 浏览器会根据响应头部的缓存控制信息来管理缓存，以便在后续访问相同资源时提高性能。关于这一点，详见<a href="hc">缓存</a>。
#### 浏览器是如何做到的
##### 一些概念
* 浏览器是一个软件(或者叫应用程序，甚至叫它app)
毋庸置疑，浏览器是一个应用软件，无论手机浏览器还是电脑浏览器，它们可能在一些细节上不同，比如屏幕尺寸、处理能力、网络信号(我也不想拨号上网)、输入方式(触摸屏幕、键鼠)。
* 进程、线程
进程(Process)是一个计算机中的基本执行单位，享有独立的空间。一个应用程序向计算机要一个进程就够用了，不过也可以要多个。进程之间想要通信需要遵循IPC机制。
线程(Thread)是进程中的小兵，一个小兵可以全揽工作(说的就是你，单线程的js)，或是我们招募更多的小兵。
* 事件循环
js是一种单线程的编程语言，这意味着在同一时刻只能执行一个任务。然而js通过事件循环（Event Loop）机制实现了非阻塞的异步编程，以处理`并发`任务和事件。
js引擎通过维护消息队列，来存放待执行的任务。事件循环不断地检查消息队列，如果队列中有任务，就将任务取出并执行。
这里有`宏任务和微任务`的概念，但图像、视频或许是更好的理解其的方式。
需要注意的是，根据浏览器的不同，或是版本的不同，可能会有细微的差异。
而实践中，当你产生任务执行顺序先后的困惑时，除了搜索，不如使用打印来看看实际效果。
##### 正题
我推荐你观看[这里](https://www.bilibili.com/video/BV1x54y1B7RE)，里面有所有的内容。如果这个视频因为某些原因不在了，下面是我的笔记：
```

map(i=>i.a) 
falt 
faltmap
filter(i>1)
reduce(toal,)
for in ()



浏览器分为三个部分用户界面 浏览器引擎 渲染引擎(网络模块、js解析器)
    浏览器个多进程结构，
        1. 浏览器进程:控制除标签页外的用户界面，包括地址，书签，后退，前进按钮等，以及负责与浏览器其他进程负责协调工作2.
        2. 缓存进程 比方cookie
        3. 网络进程  发起网络请求
        4. 渲染器进程    渲染Tab  有可能会为每个标签页是一个渲染进程 这在官方文档上可以看到
        5. GPU进程  渲染
        6. 插件进程    内置插件
    当在地址栏输入地址时，浏览器进程会创建UI线程捕捉内容
        if：网址
            会创建网络线程申请DNS解析
            对于返回的IP (谷歌)浏览器使用SafeBrowsing进行安全检测 (就是是否强行访问那个)
            return：网络线程结束任务，UI线程该你上了
          UI告诉进程干活了
        if：关键词
            使用搜索引擎查询
        final：
            Browser Process通过IPC传信 使渲染进程(Renderer Thread)工作 渲染页面
        Renderer Therad的主线程进行html解析，构造DOM数据
            对于css、img等会直接从网络下载或从缓存加载 不会影响DOM构造
            但遇到js会暂停DOM加载，(比如doucument.write)来修改html，所以js的位置很重要。

        html解析完成后，会获得一个DOM Tree，此时主线程解析css来为每个DOM节点提供样式，浏览器有自己默认的CSS样式表。
        完成后，需要确定每个节点的位置，这个阶段成为layout布局。
            主线程通过DOM构造和js解析的样式来生产Layout Tree
                设置的display:none不会显示在layoutTree上，
                而在伪类上 比如 div::before{content:'xx'} content里的内容会出现在LayoutTree上（不会出现在DOM树上）
            这是因为DOM树是html解析获得 不关心css，而Layout树是根据DOM和计算获得
            z-index会影响Layout层级关系
      此时主线程遍历Layout树，获得绘制(paint)信息(LayerTree+绘制顺序)，是时候变成像素了。
        主线程将绘制信息传递给合成器线程，合成器线程将绘制信息中每个图层 栅格化，然后把图层切成图块，
        栅格线程将图块存在GPU中，当所有的栅格化完成后，合成器线程生成合成器Frame帧 将帧通过IPC传给浏览器进程
        浏览器进程将帧送给GPU 
        GPU再渲染显示在屏幕上！
        页面的变化由合成器生成新的帧传给GPU。
```
额外的：
页面动画的卡顿：
    对于一个不断导致触发重排重绘的动画，Browser需要在每一帧都运行样式计算布局和绘制操作。
        重排(当改变一个元素的位置属性时，会重新进行样式计算、布局、绘制等流程)、重绘(改变颜色时，不会重新布局，但会出发样式计算和绘制)都会占用主线程，当占用时间过长会导致没来得及给下一帧渲染。
    well-known 60帧/s 才不会让用户感到卡顿，style-layout-paint JavaScript style-layout-paint
        当js不及时归还(阻止了主线程) 就会造成卡顿
    优化手段:requestAnimationFrame() 即将js分成小块放到每一帧之间，以便主线程按时执行布局和绘制。
        React Fiber渲染引擎就是使用的上述方法。
        Transform不会进入合成器线程和栅格线程，不会受到主线程影响，很节省时间。
    回流 即 重排
### 如何写出自己的页面
#### 编写一个页面是如此的简单
你只需要在桌面上新建一个txt文件，然后在里面输入:哈哈。
保存后再将文件后缀从.txt改为.html。(如果你看不见文件的后缀，就去搜一下如何看到文件后缀)
双击打开，你就能从浏览器上看到自己的页面了。
你可以通过这种方式编写所有需要的页面功能，但更好的方式是使用vscode来编写，就相当于普通的文本编辑器和高级的文本编辑器。
相比于下载vscode然后在里面新建.html文件，去找一个文字/视频教程来学习是更好的方式，比如搜索：前端入门。
其中不仅仅有vscode里如何写html，你会看到完全不同的思路去前端入门，以及如何使用本地服务访问你的网站(而非打开一个html文件)，例如vscode的Live Server。
或者去w3cschool、MDN，从多角度去了解也是很好的方式。
随着你的学习，或多或少，你掌握了一些html标签、css样式、js编程，这也是最基本的前端三剑客，甚至你早早的学习了更多的内容。
不必担心需要记住如此之多的内容，你只需要大概有个印象，只要知道自己需要什么，那么总可以通过搜索的方式找到需要的内容，然后熟能生巧。
#### 不仅仅是前端
不过如果你想做的不仅仅是前端(编写页面)，那么下面是基础的后端(让别人访问页面)流程，你可以完全自己维护网站。
在你操作系统默认的设置中，.html后缀会由你已安装的某个浏览器打开。
但这只能看到你自己的页面，你现在希望别人访问自己电脑的时候能访问到这个页面——也像自己访问其它网站一样。
计划是这样的：
* 首先是一些名称，现在当我的电脑现在应该叫`服务器`了，炫酷的名字，因为我们即将有访问我们计算机资源的客户。我们需要安装一个软件(或者是自己编写)，专门让它来接受外部的http请求，然后处理请求，并生成http响应，然后发送给请求者。它应该还有更多的功能，比如如何处理包装我们的内容、考虑安全问题、进行监控和记录，姑且叫它是`web服务器软件`。
* 恰好有一些现成的web服务器软件，比如Apache、Nginx等等，通过对他们的学习，我们就可将我们的页面部署到互联网上了，别人可以通过我们ip地址，向我们发送http请求了。
* 或许你需要处理其它协议，或许你需要一个数据库，或许你要做更多的事情，去找一些教程吧，很快你就能成为全栈的开发者......的入门阶段。
#### 深入基础
这个章节或许出现的过早了，你可以快速浏览，等到合适的时候再次浏览。
##### 关于页面布局
这里并不会像MDN一样有非常贴心的新手引导和全部细节(盒模型、文本相关、overflow、shadow、display、float、position、BFC、background、伪类伪元素、媒体查询、vh、vw、rem、%、flex、grid、过度、渐变、动画)等等，我们只会举几个典型的例子。
* 在一个容器中，两个元素固定大小，另外一个元素占据剩余全部空间，文字是不易描述的，详见[flex布局](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox#flex_元素上的属性)。
* 二级列表
仅需  ul>li>ul>li + 子元素隐藏
    对此 可通过子代选择器(>)和后代选择器 针对性设置样式 
    ul>li这种写法叫做Emmet，vscode已经内置了常用的Emmet
子元素隐藏的方式，可以是：
    ul{display:none}
    .father:hover ul{display:block}
* 整块超链接
    a{display:block}
* 文字内容小于1行时居中 大于1行时靠左
    p{display:inline-block;text-align: left;}
    .father{text-align: center;}
##### 关于html元素
* 一些标签很少有出场的机会，或许一些标签已经废弃了，但不常用的标签中依然有一些很有趣的，比如：<map>和<area>标签的联动、<datalist>与<search>标签的区别
* 有没有尝试过使用<dialog>创建对话框、或是<details>创建细节，多去浏览和尝试标签是很有趣的
* <iframe>可以在一个文档中嵌入另一个文档，想想在你的网页中同时还可以浏览视频网站，或许你还能在微前端技术栈看到它。
* <script>这里，实际上，脚本内容(js代码)都是在这里被添加到页面中的。常见的，我们可能指定type为module或是importmap、或是使用async、defer。
###### 全局属性
在<div id='' class=''>中，id和class是常见的全局属性，除此之外还有很多，比如[data-*](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/data-*)。
##### 有必要多聊一聊js
html和css的内容是这么清晰明了，需要什么就使用什么，而编程则往往需要花费一些脑筋。
好在出现了很多现代框架和一些封装好的函数库，学会如何使用它们就能快速的完成常见的内容。不过这也可能导致一个前端程序员生疏了他们的编程能力。
(框架不是专有名词，而是任何东西的基础架子)
###### 举例来说
或许在一些页面中，我们看到了一个叫做轮播图的东西，这个东西是如何实现的呢？
你想到了使用CSS动画，通过关键帧、translate、控制显示的区域来实现同样的效果，没错，确实可以做到。但你可能随时替换图片资源、图片的多少，你还想实现左右箭头、鼠标悬停时图片不滚动等等。这时就需要js了。
但令人头疼的是，如何编写这样一个功能呢？回想CSS动画版本，因为我们知道如何展示动画，也知道如何展示一部分区域，并且通过CSS控制元素的位置，所以，js也是一样的。
我们需要知道js能做哪些东西，所以系统的学习JavaScript这门编程语言。
[这里](./src/轮播图3.html)是一个js轮播图的实现，你也可以找到更多的资源来学习实现更多功能，例如懒加载与瀑布流、放大镜、三级联动、秒表、连点器等等。
###### 然而
系统的学习js是扎实基本功的过程，不过依然有一些逃课的方法，比如去网上找到现成的关于轮播图的代码直接复制贴贴，或是使用一些成熟的轮播图组件。
这的确是实现轮播图功能的好方法，但并不是开始学习js的好方法。
诸如此类，以至于这样一种情况：很大概率，面试官会提问你关于es6的新特性，而实际上，es6已经是2015年就已经出现并被广泛使用的了。
我们应该警惕这样的情况，避免从一个程序员变成一个cv工程师。
###### 如何学习js
MDN依然是不错的选择:https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript，此外还可以看一些其它的，例如视频教程。
不过实践与复习是很重要的。
或许在未来，这里会被扩展出更多js的内容，毕竟它是前端编程的核心。
##### 这里详细展开说js？
#### 快速通关(TODO)
有时候写js是如此的无助，完成某个功能要写上如此多的代码，你决定在js的上层去实现一个更好用的编程方式。
你想到 缩写是一个好方式
去过可以 $('#hh')就可以代替docuemnt.getElementById('hh'),这真是太棒了！
接着你又觉得写html是如此的无助，完成某些页面元素与js的交互是如此的麻烦，你决定写一个更好的书写html的方式！如果能将通过js展现到页面上的内容通过html展示，就会方便很多。
比如你有一个列表，里面所有的数据都来自于js。
那么需要使用js访问到每个对应的dom节点，然后一次的将内容注入。
但你现在可以：
`把那段代码复制过来`


有时候，你觉得编写css是如此的无助，你需要考虑这么多的(这里可以举例，比如样式穿透、作用域、行内、级联、外链)样式的关系，你决定发明一种更为简单明了的css。TailwindCSS

甚至你觉得或许可以将他们融合在一些，或许可以管他叫.vue，真是不错的创意！
而且还搭载了响应式数据、路由管理、状态仓库、双向绑定，这真是太酷了！


这真是太棒了！但有时你觉得，每次都要做这些重复的工作是如此的无助：创建项目文件夹、设计项目架构、编写默认通用的配置、webpack配置。。。
你决定做一套基础架子，这样每个项目开工的时候都可以使用这一套架子。或许可以起名管他叫Vite，就这么定了！

当你回首整个前端领域时，你终于能愉快的和你的用户进行沟通了。
不过路漫漫其修远兮，下一步是什么？
### 尝试更便捷的书写方式
没有比框架更便捷的方式，不过我们还是循序渐进。
#### 模板语法
有没有想过这样实现你的前端页面：
```js
{{if user}}
  <h2>{{user.name}}</h2>
{{/if}}
```
如果user这个变量存在，那么我们就使用一个h2元素显示user的name。

这是一种`模板语法`，模板语法允许你在 HTML 或其他模板文件中插入动态的变量、表达式和逻辑，并根据数据的变化来更新页面。
以上的代码来自于[artTemplate](https://aui.github.io/art-template/zh-cn/index.html)。
在一些主流的前端框架中都使用了模板语法，例如React、Vue。
可以这样理解`模板`二字的意思:
var name = "John";
var age = 25;
var template = "My name is " + name + " and I am " + age + " years old.";
#### 扩展CSS
有一些情况让你觉得应该有更好的css书写方式，例如：
* 我需要将一个颜色值写在好几处，能否声明一个变量，然后四处引用？然后加一点细节，通过一个按钮就能将主题修改为黑夜模式。
* 我希望选择html中class="ck_cent"下的p标签，对应的，能否让css也变得嵌套起来？
甚至是你希望实现更多的功能，而[Sass](https://www.sass.hk/guide/)、[Less](less.bootcss.com)等等就在做这样的内容，它们被称为`CSS预处理器`，因为其需要使用编译器将sass、less代码转换为标准的CSS文件。
sass[快速上手](./src/a.scss)
##### 另外
原生css也同样实现了变量功能。
`PostCSS`可以自动添加浏览器前缀，使用最新的css语法以及避免命名冲突，很多工具内置了它。
##### 原子化CSS
[Tailwind](https://www.tailwindcss.cn/)是一种截然不同的css书写方式,作者本人这样说：我相信 你会后悔自己为什么曾经用其他的方式写 CSS。
而这里是一篇比较不错的上手教程[快速掌握 Tailwind：最流行的原子化 CSS 框架](https://juejin.cn/post/7231539903649398843?searchId=20231003165524F0B40D3C8C8BEA535E50)。
#### js
##### 模块化
或许你已经使用模块了，而在早期，全局命名冲突和代码混乱使得开发者使用了自执行函数模块的方式，不过缺点就是没有良好的依赖管理和导出机制。
后续出现了nodejs的commonJS和前端AMD规范的RequireJS，而es6则推出了原生的模块系统，也是现有的标准。
这里是关于模块的[概览](./src/模块化.txt)。
##### 三方库
使用一些库无疑是提升效率的好方式，例如[lodash](https://www.lodashjs.com/),只需要引入，然后使用。对于现代工程工具来说，模块化的库会更加友好，应该转而使用es-lodash。
##### 框架
在早期，jQuery是一个流行的js库，可以更简单的书写一些js内容，封装了常见的功能等等，然而其不适合单页应用(SPA),对DOM频繁操作等原因，渐渐隐去身影，但并不妨碍简单了解一下。
```js
// Get the <button> element with the class 'continue' and change its HTML to 'Next Step...'  这里指的是innerHTML
$( "button.continue" ).html( "Next Step..." ) 
```
Angular使用脏检测，这不同于React和Vue的变更检测策略————虚拟DOM，这或许是Angular鲜有人用的原因之一，不过Angular2脱胎换骨，是与1完全不同的东西了，而VUE与React，一个是全球最流行的框架，一个是国内最多使用者的框架，有必要开一大章去聊一聊。
### 聊聊浏览器API
#### 运行时
js代码的执行环境(js runtime environment)提供了一些基本设施和功能，如浏览器和Node.js，更具体来说是指其内的js引擎，如Chrome的V8引擎(另外要提到一点的是，V8内部编译js，使其高效，并不是完全的解释型语言)。
可以理解为，js是语言，而引擎是语言的使用者。
在浏览器中，window是js runtime的顶级对象，所有的全局变量、函数都是window对象的属性，其提供了js与浏览器的交互能力。而nodejs的全局对象是global。
#### 举例
Application Program Interface,最简单的理解就是：Number.add(1+1)，add就是Number对象留下供以使用的接口。既然window是最上层的东西，那么所有属性都是浏览器api。
以下的例子的排序由常见到少见排序，更多可见于[Web API 接口参考](https://developer.mozilla.org/zh-CN/docs/Web/API)
* window.document，提供了DOM相关操作，例如 document.getElementById
* 用于网络请求的XMLHttpRequest、fetch
* 打印常用的console，或许你喜欢使用.clear来清屏一次、.error的红色提醒
* Navigator用于请求运行当前代码的应用程序的相关信息，例如用户代理、地理位置
* 直接对css更改的CSSRuleList，监听dom变动的MutationObserver
* webGL、webSocket、webRTC、webWorker
#### 一些api并不常用
h5依然在发展中，内容增增删删，有些api只限于特定的场景，比如webNTF近距场通信、webSpeech语音处理、WakeLock屏幕唤醒、Vibration震动反馈、webXR混合现实等等。
相对的，它们可能有一些直接生成手段,例如 全景VR制作软件可以直接输出成HTML5静态网页
#### 做一些工具

### VUE与React
#### 它们是框架
使用一个框架可以帮助我们更便捷的开发前端项目，搭配一些常用的库，就能实现一部分的前端项目的构建所需以及快捷的开发方式，从而让开发者更加专注于业务内容，而免于繁杂的琐事，是快速搭建一个项目的不二选择，也是新手上手的良好方式。
#### 如何学习
去官网就好了，里面应该提到了完整的周边生态，然而对于新手还需要跟几个demo，同时注意版本，放轻松，都是渐进式的。
#### 它是如何做到的？
其官网都有提到理念和部分原理，而在前些年，阅读vue和react的源码着实火了一阵，一些文章也很优秀，例如[React技术解密](react.iamkasong.com/diff/one.html),里面提到了React的理念、Fiber架构的心智模型、beginWork、mutation、Diff算法、hooks等等，Vue也差不多。Vue响应式原理的Observer、Dep、Watcher也常常被提到。不过聊这些之前，基础看起来更重要。
### 现存前端的问题
#### 框架
看看现在前端的一些概念：hooks、 effects、 props、 portals、 watchers, provides、 injects、 suspension、 ref、 minxin、 reactive、 computed、watch、solt、emit、预构建、兼容性、loader、plugin、bundle、chunk、tree shaking等等或者是任何的自定义的抽象方式,这使得一个前端开发人员不得不去将一堆东西组合在一起，有些事情变得令人困惑。
#### 用户体验与js编程
尤其对于那些精通html和css的人，他们做出了很棒的用户体验，但却并不擅长编程。而擅长js的人也同样有感，即便使用原子化的css，但是繁多复杂的相关工具、难以理解、网站臃肿等等问题也扰乱了他们的心智。大家开始尝试去理解流程，手动构建那些工具；尝试阅读源码，希望从中学到原理，一方面是希望学到什么，另一方面，随着工具链的增长和变得越来越复杂，除非非常熟悉它们，否则在我们的代码中发生的转换是非常不清楚的。
使用工具的初心是为了降低成本，但反而增加了某些成本。
不过或许不需要太多的人将精力放在这里，而将精力转移到他们的用户体验和功能实现上，就像VUE框架的作者尤雨溪所说的：没必要去阅读vue的源码，会使用就可以了。在过往的项目经历中，事情总是一次次变得更好，项目条理和"完善的参考手册"也是如此的清晰，但依然在或长或短的时间后依然变得维护困难，这是绝大多数前端目前都在面临的问题。面临这些，将能做的做好就可以(例如`企业项目`小节中提到的)。
#### ts
另外一点是关于ts，仅仅是我的一点点看法，写在之前:
在阮一峰第272期中提到了一篇放弃ts的文章，我个人也是如此主见。
不像其他的强类型语言(例如C、Solidity)，ts像是一层不太合身的护甲，看起来略显尴尬，而且ts使用者往往与js使用者存在着相互鄙视:ts使用者不使用ts就像丢了拐杖，js使用者连接口、抽象都不会。
如果你正在写一个类，没有ts帮助看起来有些麻烦。
设想你有一个变量，它存放了用户的某种数字标识信息。那么声明它是number类型就可以了吗？它是否是自然数？是否应该改为枚举？或是其它的某些规则限制？
解决的实际方案是，转而对团队开发者而言，项目的一致协调是更重要的。
或许我们应该先做好项目文档，编程规范，代码注释，单元测试，然后再思考：如何与项目成员高效的交流与合作。
一份[ts笔记](./src/ts语法.txt)
这里是一些[小工具](./src/Utils/)，以及js和ts的对比版本。
这是AMD的[代码](./src/require.js)，虽有些复古，但很好的用来参考js规范。
### 构建生产环境
#### 直接使用框架
这里是React的[Next](www.nextjs.cn/)和[Umi](https://umijs.org/docs/guides/getting-started)，这里是Vue对应的[生产部署](https://cn.vuejs.org/guide/best-practices/production-deployment.html)在这里，其内也有关于`Vite`和`Vue-cli`生产部署的说明，其`性能优化`也详细说明了何时我们进行怎样的方式进行优化。

如果是跨端跨框架应用的上手，那么我推荐[Taro](https://taro-docs.jd.com/docs/)和[uniapp]，进而继续使用VUE或者React，这降低了学习成本，例如React Native、微信小程。
不过，这这些推荐是于现在来说，时光飞快，技术的发展飘忽不定，期望[Nue](https://github.com/nuejs/nuejs)和一众致力于前端发展的内容都能生机勃发吧！
#### SPA与MPA
使用vite或nextjs等构建应用，你会发现默认只能看见一个index.html或类似的，它现在是SPA。
SPA指的是单页web应用(single page web application),只有一张web页面(一个.html文件)。
SPA改变url和页面显示内容的方式是前端路由和使用js更新DOM，前端路由技术拦截了url变化事件([如何监听URL的变化](https://juejin.cn/post/6844903749421367303))然后映射url与组件(路由的本质)，而js更新DOM则使用了虚拟DOM。
在一些文章中有对于SPA与MPA的优缺点有一些对比，不过随着发展，这也是未定之事([谷歌谈SPA架构是如何影响网站核心指标的？](https://juejin.cn/post/7172020291026026532))。
或许看一些例子是更加明确的,例如[Application Holotypes](https://jasonformat.com/application-holotypes/) 一文中讨论了 Web 应用的类型以及它们各自的理想实现/交付方式。
#### 性能优化
web应用性能主要的两个方面是页面加载性能和更新性能，显然框架做了很多的相关工作，而如果遇到一些性能问题，那么通常其是独特的，不过也有例如像v-once、v-memo、[保持prop稳定性](https://cn.vuejs.org/guide/best-practices/performance.html#props-stability)这样通用的优化技巧。
而如果你有希望了解更多前端构建流程，这是我喜欢的[文章](https://juejin.cn/post/7145855619096903717)，里面包含了webpack、rollup、vite三部分的原理与实践。
#### 资源优化
你的一些小型内容可能会被转为base64，但也仅仅是转换。你需要自己考虑资源的格式与是否需要压缩，了解svg、webp、或是其它任何有助于性能的格式(例如3d中使用gltf替代fbx)。
#### 缓存
* 强缓存与协商缓存整个过程都是由服务端控制，不过在开发阶段我们可能也需要让后端帮助缓存一些内容来加快开发体验，[这里](juejin.cn/post/7197388515230433337)是一篇详细的解读。
* 有时候你可能考虑使用CDN缓存，即便不是自家的资源，这很方便。
* Vite 会在生产构建中为生成的静态资源文件添加哈希后缀，并在它们的 URL 中包含该哈希值。这样，当文件内容发生更改时，哈希值也会发生变化，从而强制浏览器重新下载新版本的文件。——这一条的目的是，在本节的最后提醒你记得操作时多查一查操作手册，毕竟有时候我们会忽略一些内容。
#### CDN

### 企业项目
对于一个项目的前端部分，网站性能和用户体验往往是最重要的，基于公司特点构建一套适宜的生产流程也是重要的。
不过回头过来，最重要的事情还是要理解项目，理解需求，然后寻找解决的方式。现在流行的一种通用解决方式是MVP——Munimum Viable Product——最小可行性产品，然后根据进一步的需求与反馈不断的迭代优化，具体到前端，就是先做出基本的功能单元，项目的基本架构，然后根据需求、反馈不断的向上搭建。换一种角度，拦在项目面前的大山——完美主义与理想主义，完美主义让我们把目标定得太高，理想主义让我们认为目标容易达成，这导致面前的大山太高太近，压迫自身。
不必再一开始就追求完美适配的架子，事实上，一个非常常见的情况是任意大小的项目总在几个月后变得难以维护，一方面的原因是现有框架的限制，另一方面是缺乏对项目更加细致的呵护。举一个例子，在example.vue中，CSS样式存在了行内式、外链式，style标签中又包含了多层级嵌套和四处游荡的单层选择器与样式穿透，让人伤透脑筋。
所以一套默认或者定制的流程就显得重要，可能大家的习惯略有不同，但合作就意味着需要有一点点的协调性，所以让事情变得明确起来。
* 另外一点
在阮一峰的286期中说到：软件需要有人通盘理解它的运作机制，所以单个工程师有可能比一个职业开发团队造出更好的产品。因为单个工程师花时间，完整理解了他要构建的软件，而职业开发团队总是从一个项目转移到另一个项目。

这也是为什么接手不熟悉的项目，比重建该项目要困难得多，以及为什么软件外包的质量总是如此糟糕。
* 尽管在下面的团队合作小节中有说。但是一些事情似乎是只有你知道的，而你是没有权限去改变什么的。他们需要的是一个公司内部用的管理系统，当然，开发一个的成本很高，转而[应该试试这个](./src/飞书.md)

#### 备份
几年前的项目只剩打包好的版本，原型找不到等等，我们可不想遇见这样的情况。如此强调，只是因为见过，人们不注意一些事情，直到需要的时候。你可以参加
#### 团队合作
##### 通用(以UI举例)
如何还原UI的设计一直是一个问题，尽管下方的内容有些书面化了，但的确是要做的事情。
* 建立良好的关系： 在开始项目之前，建立一个积极友好的关系。理解并尊重设计师的视觉和创意决策，这有助于建立互信和合作。

* 仔细阅读设计文档： 如果设计师提供了设计文档或UI规范，务必仔细阅读并理解其中的要求。这些文档通常包括颜色、字体、间距、图标等详细信息。

* 提前反馈： 在项目早期，向设计师提供反馈，讨论设计的可行性和技术实现的难点。这有助于及早解决潜在问题，避免后期的麻烦。

* 主动沟通： 保持开放的沟通渠道，定期与设计师交流，分享进展并提出问题。这可以避免在项目的后期出现重大偏差。

* 尊重设计决策： 如果你认为某些设计不符合最佳实践或会影响性能，尽量以建设性的方式提出问题，并尊重设计师的决策。寻找解决方案，而不是仅仅批评设计。

* 关注细节： 在实施设计时，确保准确地匹配设计规范，包括颜色、字体、图标和间距。细节对于用户界面的外观和体验至关重要。

* 示例和演示： 如果可能，使用示例和演示来说明你的开发进展，以便设计师可以实际看到实现的效果，这有助于解决任何误解或不匹配。

* 反馈和修正： 如果发现实施中的问题或与设计规范不符，及早向设计师报告并请求修正。及时的反馈和修正有助于避免在项目后期进行大规模的修改。

* 跨职能团队合作： 在项目中，前端开发者、设计师和其他团队成员应该密切合作，以确保最终的用户界面满足设计和功能要求。

* 不断学习： 前端开发者应该保持对最新的UI/UX设计趋势和技术的了解，以更好地理解设计决策的背后逻辑，并提供有关技术实施的建议。
##### 后端
B/S架构的一个重要的时间节点是前后端分离，这为前端的发展带来了更大的自由度，工程化、组件化、SPA，而后端也可以进行相对独立的开发、自由的技术栈、扩展性和可维护性于灵活的部署方式，随之而来的是如何进行高效的前后端交流。
* 一点是使用本地接口模拟开发，避免使用生产环境调试，这样可以大幅提高效率，前后端也可以单独进行mock，来方便的进行开发调试，这就需要规范的接口文档。
* 根据公司、项目、开发者的习惯与逻辑，定义一套规范的接口文档，然后熟悉它，就能愉快开发了。接口文档通常是由一些文档服务或者markdown+git等等，怎么舒服怎么来。
* 查看控制台浏览器的缓存，有时需要禁用它。
* 了解一些后端内容，这样能更愉快的交流，跟一个nodejs+mongodb/mysql的demo是快速上手后端的方式，甚至是做一个简单的全栈内容。
##### 前端
有人擅长h5标准、有人擅长可视化绘制，有人天天写Object.seal()、Reflect.ownKeys，有人来几个炫酷css动画，有人搞几个loader、plugin，大家各有所长，但项目不会。互相如何合作，而不仅仅是是如何分配。
##### 其它
* 其它接口
例如机器人操作系统，通过`roslib`，可以在浏览器中使用js连接到 ROS 主节点（master）并订阅主题、发布消息等。
诸如此类的网络请求接口。
* 资源提供
例如3D建模，其提供了模型资源，资源类开发时应确定可选方案、资源类型等等，多做一些功课。
### 更多的搜索推荐
SEO Search Engine Optimization 搜索引擎优化
在这里[SEO、NUXT、SSR](./src/SEO、NUXT、SSR.txt)
### 更多的内容(TODO)
#### 视频
如果是视频资源的话，例如mp4文件，那么放在video标签里即可


#### 网络通信
当用户请求到你的页面之后，他可能请求更多的内容，比如当前页面中你展示了3只可爱的小狗，并且设置了一个按钮：当用户点击这个按钮时，用户的浏览器就会再次访问服务器，服务器就会再次返回三只小狗的图片，这也用户就能再多看到三只！
#### 实时的网络通信
ws
#### 展示更多的数据
有时候我们想把更多的内容送给用户观看，也希望记录用户输入的一些信息。
我们可以建造一个存放数据的仓库，以供发给需要的人。
我们可以在页面上提供一个表单、表格，让用户输入信息，这样我们就能获取用户的输入。
你还可以在按钮上做一些设置，这样每次用户点击按钮，你也能知道。
#### 使用页面与访问者进行交互
下载文件

请求摄像头权限

#### 整理你的项目文件
当你的.html .img .css .js 等等文件太多了
你的网络可能会堵塞，用户的体验也更差，甚至无法访问你的网站！
你会去考虑多种方式来优化自身的网络
很自然的，如果发送更少的东西，或者是更多的发送能力都是好的选择


babel、webpack、
#### 如何展示音视频？
#### 虚拟现实？
#### 图像图表
#### 3d内容
#### 人工智能？
#### 框架
#### 微前端
对于同一个B客户，有n多个项目服于与他，切换系统是，页面都会刷新，体验很差。儿开发层面，其都有一些相同之处。
简而言之，微前端会将所有项目一同载入，而非刷新页面。
左边固定右边适应

#### 混合框架、原生软件
跨段





## web3
随着算力的提升，或许在未来的某一天或许web3会普及，尽管目前它限制于金融相关的领域，Patrick Collins说: 开发去中心化应用，就是去建设一个大家相互信任，承诺必会兑现的世界，基于区块链的设计理念，不同的社区将会在一个新的系统中，进行相互协作。
如果想学习的话，清北都有公开的区块链课程在B站，或者通过[这里](./src/web3.md)快速了解。



##
并发请求 但只能6个 网络拥堵 使用http2/3在前端和node中台 然后接口转发 减缓拥堵
烟台：人工智能 研发部 技术100+ 移动开发 pc端(低代码平台) 需要前端维护 
```js
var myJoin = (arr,para)=>arr.reduce((t,v)=>`t${v}${para}`,'').slice(length-para.length,)
```

